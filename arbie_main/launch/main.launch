<launch>

    <arg name="simulated"/>
    <arg name="joints_connected"/>
    <arg name="pcb_connected"/>


    <!-- ===== MODEL ===== -->

    <param
        name="robot_description"
        command="cat $(find arbie_description)/model/arbie.urdf"
    />


    <!-- ===== VIRTUAL OR REAL HARDWARE ===== -->

    <group if="$(arg simulated)">
    <!-- Assumes that gzserver is running -->
    <node
        name="spawn_model"
        pkg="gazebo_ros"
        type="spawn_model"
        args="-param robot_description_sdf -sdf -x 0 -y 0 -z 0 -model arbie -b -gazebo_namespace gzserver"
    />
    </group>

    <rosparam
        file="$(find arbie_main)/config/usb.yaml"
        command="load"
    />

    <group if="$(arg joints_connected)">
        <include file="$(find arbie_hardware)/launch/main.launch"/>
    </group>

    <group if="$(arg pcb_connected)">
    <node
        name="power_board"
        pkg="rosserial_python"
        type="serial_node.py">
        <remap from="~port" to="/usb/pcb"/>
    </node>
    </group>


    <!-- ===== CONTROLLERS AND STATE PUBLISHER ===== -->

    <!-- Start robot_state publisher, which does FK for the robot joints,
    updating the state of the model -->
    <node
        name="robot_state_publisher"
        pkg="robot_state_publisher"
        type="robot_state_publisher"
        respawn="false"
        output="screen">
    </node>

    <!-- Load controller configuration for the robot joints -->
    <rosparam
        file="$(find arbie_main)/config/controllers.yaml"
        command="load"
    />

    <!-- Spawn the joint controllers, both for manual joint control, and
    trajectory following -->
    <node
        name="controller_spawner"
        pkg="controller_manager"
        type="spawner"
        respawn="false"
        args="arm_position_controller tracks_velocity_controller flippers_velocity_controller joint_state_controller"
    />
    <node
        name="controller_spawner2"
        pkg="controller_manager"
        type="spawner"
        respawn="false"
        args="--stopped arm_trajectory_controller"
    />


    <!-- ===== MONITORING AND TELEOPERATION ===== -->

    <!-- Launch the webserver for visualisation and user input -->
    <node
        name="webserver"
        pkg="roswww"
        type="webserver.py"
        respawn="true"
    />
    <include file="$(find rosbridge_server)/launch/rosbridge_websocket.launch"/>

    <!-- Necessary for accessing tf information on web viewer -->
    <node pkg="tf2_web_republisher" type="tf2_web_republisher" name="tf2_web_republisher"/>

    <!-- Read and process gamepad values -->
    <node
        name="gamepad"
        pkg="arbie_gamepad"
        type="gamepad">
        <remap from="joy" to="gamepad/values"/>
    </node>

    <!-- Launch the moveit move_group node, used for planning and executing
    trajectories -->
    <include file="$(find arbie_moveit_config)/launch/move_group.launch"/>

    <!-- Manipulation node, which controls the arm. Either moves arm with
    velocity commands, or passes pose commands to the moveit move_group node-->
    <node
        name="manipulation"
        pkg="arbie_manipulation"
        type="manipulation"
        output="screen"
    />


    <!-- ===== PERCEPTION ===== -->

    <!-- Placeholder for perception stack. Outputs base transform of robot -->
    <node
        name="localisation_placeholder"
        pkg="arbie_debug"
        type="localisation_placeholder"
    />


    <!-- ===== NAVIGATION ===== -->
    <!-- TODO -->

</launch>
